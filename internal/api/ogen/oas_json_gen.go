// Code generated by ogen, DO NOT EDIT.

package api

import (
	"math/bits"
	"strconv"
	"time"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"
	"github.com/ogen-go/ogen/json"
	"github.com/ogen-go/ogen/validate"
)

// Encode implements json.Marshaler.
func (s *AdditiveType) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AdditiveType) encodeFields(e *jx.Encoder) {
	{
		if s.AdditiveID.Set {
			e.FieldStart("AdditiveID")
			s.AdditiveID.Encode(e)
		}
	}
	{
		if s.AdditiveDescription.Set {
			e.FieldStart("AdditiveDescription")
			s.AdditiveDescription.Encode(e)
		}
	}
	{
		if s.AdditivePercentage.Set {
			e.FieldStart("AdditivePercentage")
			s.AdditivePercentage.Encode(e)
		}
	}
}

var jsonFieldsNameOfAdditiveType = [3]string{
	0: "AdditiveID",
	1: "AdditiveDescription",
	2: "AdditivePercentage",
}

// Decode decodes AdditiveType from json.
func (s *AdditiveType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AdditiveType to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "AdditiveID":
			if err := func() error {
				s.AdditiveID.Reset()
				if err := s.AdditiveID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"AdditiveID\"")
			}
		case "AdditiveDescription":
			if err := func() error {
				s.AdditiveDescription.Reset()
				if err := s.AdditiveDescription.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"AdditiveDescription\"")
			}
		case "AdditivePercentage":
			if err := func() error {
				s.AdditivePercentage.Reset()
				if err := s.AdditivePercentage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"AdditivePercentage\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AdditiveType")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AdditiveType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AdditiveType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AdditivesType) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AdditivesType) encodeFields(e *jx.Encoder) {
	{
		if s.Additive != nil {
			e.FieldStart("Additive")
			e.ArrStart()
			for _, elem := range s.Additive {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfAdditivesType = [1]string{
	0: "Additive",
}

// Decode decodes AdditivesType from json.
func (s *AdditivesType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AdditivesType to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "Additive":
			if err := func() error {
				s.Additive = make([]AdditiveType, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem AdditiveType
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Additive = append(s.Additive, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Additive\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AdditivesType")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AdditivesType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AdditivesType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BatchRecordsType) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BatchRecordsType) encodeFields(e *jx.Encoder) {
	{
		if s.Record != nil {
			e.FieldStart("Record")
			e.ArrStart()
			for _, elem := range s.Record {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfBatchRecordsType = [1]string{
	0: "Record",
}

// Decode decodes BatchRecordsType from json.
func (s *BatchRecordsType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BatchRecordsType to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "Record":
			if err := func() error {
				s.Record = make([]RecordType, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem RecordType
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Record = append(s.Record, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Record\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BatchRecordsType")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BatchRecordsType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BatchRecordsType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BatchType) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BatchType) encodeFields(e *jx.Encoder) {
	{
		if s.BatchID.Set {
			e.FieldStart("BatchID")
			s.BatchID.Encode(e)
		}
	}
	{
		if s.BatchStartTime.Set {
			e.FieldStart("BatchStartTime")
			s.BatchStartTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.BatchEndTime.Set {
			e.FieldStart("BatchEndTime")
			s.BatchEndTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.BatchStatus.Set {
			e.FieldStart("BatchStatus")
			s.BatchStatus.Encode(e)
		}
	}
	{
		if s.BatchRecords.Set {
			e.FieldStart("BatchRecords")
			s.BatchRecords.Encode(e)
		}
	}
}

var jsonFieldsNameOfBatchType = [5]string{
	0: "BatchID",
	1: "BatchStartTime",
	2: "BatchEndTime",
	3: "BatchStatus",
	4: "BatchRecords",
}

// Decode decodes BatchType from json.
func (s *BatchType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BatchType to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "BatchID":
			if err := func() error {
				s.BatchID.Reset()
				if err := s.BatchID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"BatchID\"")
			}
		case "BatchStartTime":
			if err := func() error {
				s.BatchStartTime.Reset()
				if err := s.BatchStartTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"BatchStartTime\"")
			}
		case "BatchEndTime":
			if err := func() error {
				s.BatchEndTime.Reset()
				if err := s.BatchEndTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"BatchEndTime\"")
			}
		case "BatchStatus":
			if err := func() error {
				s.BatchStatus.Reset()
				if err := s.BatchStatus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"BatchStatus\"")
			}
		case "BatchRecords":
			if err := func() error {
				s.BatchRecords.Reset()
				if err := s.BatchRecords.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"BatchRecords\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BatchType")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BatchType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BatchType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BatchTypeBatchStatus as json.
func (s BatchTypeBatchStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes BatchTypeBatchStatus from json.
func (s *BatchTypeBatchStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BatchTypeBatchStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch BatchTypeBatchStatus(v) {
	case BatchTypeBatchStatusPlanned:
		*s = BatchTypeBatchStatusPlanned
	case BatchTypeBatchStatusInProgress:
		*s = BatchTypeBatchStatusInProgress
	case BatchTypeBatchStatusCompleted:
		*s = BatchTypeBatchStatusCompleted
	case BatchTypeBatchStatusFailed:
		*s = BatchTypeBatchStatusFailed
	case BatchTypeBatchStatusCancelled:
		*s = BatchTypeBatchStatusCancelled
	default:
		*s = BatchTypeBatchStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BatchTypeBatchStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BatchTypeBatchStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CertificationDetailsType) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CertificationDetailsType) encodeFields(e *jx.Encoder) {
	{
		if s.CertificationBody.Set {
			e.FieldStart("CertificationBody")
			s.CertificationBody.Encode(e)
		}
	}
	{
		if s.CertificateNumber.Set {
			e.FieldStart("CertificateNumber")
			s.CertificateNumber.Encode(e)
		}
	}
	{
		if s.IssueDate.Set {
			e.FieldStart("IssueDate")
			s.IssueDate.Encode(e, json.EncodeDate)
		}
	}
	{
		if s.ExpiryDate.Set {
			e.FieldStart("ExpiryDate")
			s.ExpiryDate.Encode(e, json.EncodeDate)
		}
	}
}

var jsonFieldsNameOfCertificationDetailsType = [4]string{
	0: "CertificationBody",
	1: "CertificateNumber",
	2: "IssueDate",
	3: "ExpiryDate",
}

// Decode decodes CertificationDetailsType from json.
func (s *CertificationDetailsType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CertificationDetailsType to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "CertificationBody":
			if err := func() error {
				s.CertificationBody.Reset()
				if err := s.CertificationBody.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"CertificationBody\"")
			}
		case "CertificateNumber":
			if err := func() error {
				s.CertificateNumber.Reset()
				if err := s.CertificateNumber.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"CertificateNumber\"")
			}
		case "IssueDate":
			if err := func() error {
				s.IssueDate.Reset()
				if err := s.IssueDate.Decode(d, json.DecodeDate); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"IssueDate\"")
			}
		case "ExpiryDate":
			if err := func() error {
				s.ExpiryDate.Reset()
				if err := s.ExpiryDate.Decode(d, json.DecodeDate); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ExpiryDate\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CertificationDetailsType")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CertificationDetailsType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CertificationDetailsType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ChemicalCompositionType) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ChemicalCompositionType) encodeFields(e *jx.Encoder) {
	{
		if s.ElementSymbol.Set {
			e.FieldStart("ElementSymbol")
			s.ElementSymbol.Encode(e)
		}
	}
	{
		if s.ElementPercentage.Set {
			e.FieldStart("ElementPercentage")
			s.ElementPercentage.Encode(e)
		}
	}
}

var jsonFieldsNameOfChemicalCompositionType = [2]string{
	0: "ElementSymbol",
	1: "ElementPercentage",
}

// Decode decodes ChemicalCompositionType from json.
func (s *ChemicalCompositionType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ChemicalCompositionType to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ElementSymbol":
			if err := func() error {
				s.ElementSymbol.Reset()
				if err := s.ElementSymbol.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ElementSymbol\"")
			}
		case "ElementPercentage":
			if err := func() error {
				s.ElementPercentage.Reset()
				if err := s.ElementPercentage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ElementPercentage\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ChemicalCompositionType")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ChemicalCompositionType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ChemicalCompositionType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ChemicalPropertiesType) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ChemicalPropertiesType) encodeFields(e *jx.Encoder) {
	{
		if s.ChemicalComposition != nil {
			e.FieldStart("ChemicalComposition")
			e.ArrStart()
			for _, elem := range s.ChemicalComposition {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.PH.Set {
			e.FieldStart("pH")
			s.PH.Encode(e)
		}
	}
	{
		if s.Reactivity.Set {
			e.FieldStart("Reactivity")
			s.Reactivity.Encode(e)
		}
	}
}

var jsonFieldsNameOfChemicalPropertiesType = [3]string{
	0: "ChemicalComposition",
	1: "pH",
	2: "Reactivity",
}

// Decode decodes ChemicalPropertiesType from json.
func (s *ChemicalPropertiesType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ChemicalPropertiesType to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ChemicalComposition":
			if err := func() error {
				s.ChemicalComposition = make([]ChemicalCompositionType, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ChemicalCompositionType
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ChemicalComposition = append(s.ChemicalComposition, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ChemicalComposition\"")
			}
		case "pH":
			if err := func() error {
				s.PH.Reset()
				if err := s.PH.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pH\"")
			}
		case "Reactivity":
			if err := func() error {
				s.Reactivity.Reset()
				if err := s.Reactivity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Reactivity\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ChemicalPropertiesType")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ChemicalPropertiesType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ChemicalPropertiesType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ContaminantType) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ContaminantType) encodeFields(e *jx.Encoder) {
	{
		if s.ContaminantID.Set {
			e.FieldStart("ContaminantID")
			s.ContaminantID.Encode(e)
		}
	}
	{
		if s.ContaminantDescription.Set {
			e.FieldStart("ContaminantDescription")
			s.ContaminantDescription.Encode(e)
		}
	}
	{
		if s.ContaminantLevel.Set {
			e.FieldStart("ContaminantLevel")
			s.ContaminantLevel.Encode(e)
		}
	}
}

var jsonFieldsNameOfContaminantType = [3]string{
	0: "ContaminantID",
	1: "ContaminantDescription",
	2: "ContaminantLevel",
}

// Decode decodes ContaminantType from json.
func (s *ContaminantType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ContaminantType to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ContaminantID":
			if err := func() error {
				s.ContaminantID.Reset()
				if err := s.ContaminantID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ContaminantID\"")
			}
		case "ContaminantDescription":
			if err := func() error {
				s.ContaminantDescription.Reset()
				if err := s.ContaminantDescription.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ContaminantDescription\"")
			}
		case "ContaminantLevel":
			if err := func() error {
				s.ContaminantLevel.Reset()
				if err := s.ContaminantLevel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ContaminantLevel\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ContaminantType")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ContaminantType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ContaminantType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ContaminantsType) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ContaminantsType) encodeFields(e *jx.Encoder) {
	{
		if s.Contaminant != nil {
			e.FieldStart("Contaminant")
			e.ArrStart()
			for _, elem := range s.Contaminant {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfContaminantsType = [1]string{
	0: "Contaminant",
}

// Decode decodes ContaminantsType from json.
func (s *ContaminantsType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ContaminantsType to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "Contaminant":
			if err := func() error {
				s.Contaminant = make([]ContaminantType, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ContaminantType
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Contaminant = append(s.Contaminant, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Contaminant\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ContaminantsType")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ContaminantsType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ContaminantsType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CoordinatesType) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CoordinatesType) encodeFields(e *jx.Encoder) {
	{
		if s.X.Set {
			e.FieldStart("X")
			s.X.Encode(e)
		}
	}
	{
		if s.Y.Set {
			e.FieldStart("Y")
			s.Y.Encode(e)
		}
	}
	{
		if s.Z.Set {
			e.FieldStart("Z")
			s.Z.Encode(e)
		}
	}
}

var jsonFieldsNameOfCoordinatesType = [3]string{
	0: "X",
	1: "Y",
	2: "Z",
}

// Decode decodes CoordinatesType from json.
func (s *CoordinatesType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CoordinatesType to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "X":
			if err := func() error {
				s.X.Reset()
				if err := s.X.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"X\"")
			}
		case "Y":
			if err := func() error {
				s.Y.Reset()
				if err := s.Y.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Y\"")
			}
		case "Z":
			if err := func() error {
				s.Z.Reset()
				if err := s.Z.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Z\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CoordinatesType")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CoordinatesType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CoordinatesType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ElectricalPropertiesType) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ElectricalPropertiesType) encodeFields(e *jx.Encoder) {
	{
		if s.Conductivity.Set {
			e.FieldStart("Conductivity")
			s.Conductivity.Encode(e)
		}
	}
	{
		if s.DielectricConstant.Set {
			e.FieldStart("DielectricConstant")
			s.DielectricConstant.Encode(e)
		}
	}
	{
		if s.Resistance.Set {
			e.FieldStart("Resistance")
			s.Resistance.Encode(e)
		}
	}
}

var jsonFieldsNameOfElectricalPropertiesType = [3]string{
	0: "Conductivity",
	1: "DielectricConstant",
	2: "Resistance",
}

// Decode decodes ElectricalPropertiesType from json.
func (s *ElectricalPropertiesType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ElectricalPropertiesType to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "Conductivity":
			if err := func() error {
				s.Conductivity.Reset()
				if err := s.Conductivity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Conductivity\"")
			}
		case "DielectricConstant":
			if err := func() error {
				s.DielectricConstant.Reset()
				if err := s.DielectricConstant.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"DielectricConstant\"")
			}
		case "Resistance":
			if err := func() error {
				s.Resistance.Reset()
				if err := s.Resistance.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Resistance\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ElectricalPropertiesType")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ElectricalPropertiesType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ElectricalPropertiesType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EquipmentType) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EquipmentType) encodeFields(e *jx.Encoder) {
	{
		if s.EquipmentID.Set {
			e.FieldStart("EquipmentID")
			s.EquipmentID.Encode(e)
		}
	}
	{
		if s.EquipmentType.Set {
			e.FieldStart("EquipmentType")
			s.EquipmentType.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("Description")
			s.Description.Encode(e)
		}
	}
	{
		if s.Manufacturer.Set {
			e.FieldStart("Manufacturer")
			s.Manufacturer.Encode(e)
		}
	}
	{
		if s.Model.Set {
			e.FieldStart("Model")
			s.Model.Encode(e)
		}
	}
	{
		if s.SerialNumber.Set {
			e.FieldStart("SerialNumber")
			s.SerialNumber.Encode(e)
		}
	}
	{
		if s.InstallationDate.Set {
			e.FieldStart("InstallationDate")
			s.InstallationDate.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Location.Set {
			e.FieldStart("Location")
			s.Location.Encode(e)
		}
	}
	{
		if s.MaintenanceHistory.Set {
			e.FieldStart("MaintenanceHistory")
			s.MaintenanceHistory.Encode(e)
		}
	}
	{
		if s.PerformanceData.Set {
			e.FieldStart("PerformanceData")
			s.PerformanceData.Encode(e)
		}
	}
}

var jsonFieldsNameOfEquipmentType = [10]string{
	0: "EquipmentID",
	1: "EquipmentType",
	2: "Description",
	3: "Manufacturer",
	4: "Model",
	5: "SerialNumber",
	6: "InstallationDate",
	7: "Location",
	8: "MaintenanceHistory",
	9: "PerformanceData",
}

// Decode decodes EquipmentType from json.
func (s *EquipmentType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EquipmentType to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "EquipmentID":
			if err := func() error {
				s.EquipmentID.Reset()
				if err := s.EquipmentID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"EquipmentID\"")
			}
		case "EquipmentType":
			if err := func() error {
				s.EquipmentType.Reset()
				if err := s.EquipmentType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"EquipmentType\"")
			}
		case "Description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Description\"")
			}
		case "Manufacturer":
			if err := func() error {
				s.Manufacturer.Reset()
				if err := s.Manufacturer.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Manufacturer\"")
			}
		case "Model":
			if err := func() error {
				s.Model.Reset()
				if err := s.Model.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Model\"")
			}
		case "SerialNumber":
			if err := func() error {
				s.SerialNumber.Reset()
				if err := s.SerialNumber.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"SerialNumber\"")
			}
		case "InstallationDate":
			if err := func() error {
				s.InstallationDate.Reset()
				if err := s.InstallationDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"InstallationDate\"")
			}
		case "Location":
			if err := func() error {
				s.Location.Reset()
				if err := s.Location.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Location\"")
			}
		case "MaintenanceHistory":
			if err := func() error {
				s.MaintenanceHistory.Reset()
				if err := s.MaintenanceHistory.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"MaintenanceHistory\"")
			}
		case "PerformanceData":
			if err := func() error {
				s.PerformanceData.Reset()
				if err := s.PerformanceData.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"PerformanceData\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EquipmentType")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EquipmentType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EquipmentType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s HierarchyScopeType) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s HierarchyScopeType) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes HierarchyScopeType from json.
func (s *HierarchyScopeType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HierarchyScopeType to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HierarchyScopeType")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s HierarchyScopeType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HierarchyScopeType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LocationType) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LocationType) encodeFields(e *jx.Encoder) {
	{
		if s.SiteID.Set {
			e.FieldStart("SiteID")
			s.SiteID.Encode(e)
		}
	}
	{
		if s.BuildingID.Set {
			e.FieldStart("BuildingID")
			s.BuildingID.Encode(e)
		}
	}
	{
		if s.FloorID.Set {
			e.FieldStart("FloorID")
			s.FloorID.Encode(e)
		}
	}
	{
		if s.AreaID.Set {
			e.FieldStart("AreaID")
			s.AreaID.Encode(e)
		}
	}
	{
		if s.Coordinates.Set {
			e.FieldStart("Coordinates")
			s.Coordinates.Encode(e)
		}
	}
}

var jsonFieldsNameOfLocationType = [5]string{
	0: "SiteID",
	1: "BuildingID",
	2: "FloorID",
	3: "AreaID",
	4: "Coordinates",
}

// Decode decodes LocationType from json.
func (s *LocationType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LocationType to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "SiteID":
			if err := func() error {
				s.SiteID.Reset()
				if err := s.SiteID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"SiteID\"")
			}
		case "BuildingID":
			if err := func() error {
				s.BuildingID.Reset()
				if err := s.BuildingID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"BuildingID\"")
			}
		case "FloorID":
			if err := func() error {
				s.FloorID.Reset()
				if err := s.FloorID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"FloorID\"")
			}
		case "AreaID":
			if err := func() error {
				s.AreaID.Reset()
				if err := s.AreaID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"AreaID\"")
			}
		case "Coordinates":
			if err := func() error {
				s.Coordinates.Reset()
				if err := s.Coordinates.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Coordinates\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LocationType")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LocationType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LocationType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MaintenanceEventType) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MaintenanceEventType) encodeFields(e *jx.Encoder) {
	{
		if s.EventID.Set {
			e.FieldStart("EventID")
			s.EventID.Encode(e)
		}
	}
	{
		if s.EventDate.Set {
			e.FieldStart("EventDate")
			s.EventDate.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("Description")
			s.Description.Encode(e)
		}
	}
	{
		if s.PerformedBy.Set {
			e.FieldStart("PerformedBy")
			s.PerformedBy.Encode(e)
		}
	}
	{
		if s.PartsReplaced.Set {
			e.FieldStart("PartsReplaced")
			s.PartsReplaced.Encode(e)
		}
	}
	{
		if s.DowntimeHours.Set {
			e.FieldStart("DowntimeHours")
			s.DowntimeHours.Encode(e)
		}
	}
}

var jsonFieldsNameOfMaintenanceEventType = [6]string{
	0: "EventID",
	1: "EventDate",
	2: "Description",
	3: "PerformedBy",
	4: "PartsReplaced",
	5: "DowntimeHours",
}

// Decode decodes MaintenanceEventType from json.
func (s *MaintenanceEventType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MaintenanceEventType to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "EventID":
			if err := func() error {
				s.EventID.Reset()
				if err := s.EventID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"EventID\"")
			}
		case "EventDate":
			if err := func() error {
				s.EventDate.Reset()
				if err := s.EventDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"EventDate\"")
			}
		case "Description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Description\"")
			}
		case "PerformedBy":
			if err := func() error {
				s.PerformedBy.Reset()
				if err := s.PerformedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"PerformedBy\"")
			}
		case "PartsReplaced":
			if err := func() error {
				s.PartsReplaced.Reset()
				if err := s.PartsReplaced.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"PartsReplaced\"")
			}
		case "DowntimeHours":
			if err := func() error {
				s.DowntimeHours.Reset()
				if err := s.DowntimeHours.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"DowntimeHours\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MaintenanceEventType")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MaintenanceEventType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MaintenanceEventType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MaintenanceHistoryType) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MaintenanceHistoryType) encodeFields(e *jx.Encoder) {
	{
		if s.MaintenanceEvent != nil {
			e.FieldStart("MaintenanceEvent")
			e.ArrStart()
			for _, elem := range s.MaintenanceEvent {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfMaintenanceHistoryType = [1]string{
	0: "MaintenanceEvent",
}

// Decode decodes MaintenanceHistoryType from json.
func (s *MaintenanceHistoryType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MaintenanceHistoryType to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "MaintenanceEvent":
			if err := func() error {
				s.MaintenanceEvent = make([]MaintenanceEventType, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem MaintenanceEventType
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.MaintenanceEvent = append(s.MaintenanceEvent, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"MaintenanceEvent\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MaintenanceHistoryType")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MaintenanceHistoryType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MaintenanceHistoryType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MaterialCategoryType) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MaterialCategoryType) encodeFields(e *jx.Encoder) {
	{
		if s.CategoryCode.Set {
			e.FieldStart("CategoryCode")
			s.CategoryCode.Encode(e)
		}
	}
	{
		if s.CategoryDescription.Set {
			e.FieldStart("CategoryDescription")
			s.CategoryDescription.Encode(e)
		}
	}
}

var jsonFieldsNameOfMaterialCategoryType = [2]string{
	0: "CategoryCode",
	1: "CategoryDescription",
}

// Decode decodes MaterialCategoryType from json.
func (s *MaterialCategoryType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MaterialCategoryType to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "CategoryCode":
			if err := func() error {
				s.CategoryCode.Reset()
				if err := s.CategoryCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"CategoryCode\"")
			}
		case "CategoryDescription":
			if err := func() error {
				s.CategoryDescription.Reset()
				if err := s.CategoryDescription.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"CategoryDescription\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MaterialCategoryType")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MaterialCategoryType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MaterialCategoryType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MaterialCompositionType) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MaterialCompositionType) encodeFields(e *jx.Encoder) {
	{
		if s.BaseMaterial.Set {
			e.FieldStart("BaseMaterial")
			s.BaseMaterial.Encode(e)
		}
	}
	{
		if s.Additives.Set {
			e.FieldStart("Additives")
			s.Additives.Encode(e)
		}
	}
	{
		if s.Contaminants.Set {
			e.FieldStart("Contaminants")
			s.Contaminants.Encode(e)
		}
	}
}

var jsonFieldsNameOfMaterialCompositionType = [3]string{
	0: "BaseMaterial",
	1: "Additives",
	2: "Contaminants",
}

// Decode decodes MaterialCompositionType from json.
func (s *MaterialCompositionType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MaterialCompositionType to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "BaseMaterial":
			if err := func() error {
				s.BaseMaterial.Reset()
				if err := s.BaseMaterial.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"BaseMaterial\"")
			}
		case "Additives":
			if err := func() error {
				s.Additives.Reset()
				if err := s.Additives.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Additives\"")
			}
		case "Contaminants":
			if err := func() error {
				s.Contaminants.Reset()
				if err := s.Contaminants.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Contaminants\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MaterialCompositionType")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MaterialCompositionType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MaterialCompositionType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MaterialPropertiesType) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MaterialPropertiesType) encodeFields(e *jx.Encoder) {
	{
		if s.PhysicalProperties.Set {
			e.FieldStart("PhysicalProperties")
			s.PhysicalProperties.Encode(e)
		}
	}
	{
		if s.ChemicalProperties.Set {
			e.FieldStart("ChemicalProperties")
			s.ChemicalProperties.Encode(e)
		}
	}
	{
		if s.MechanicalProperties.Set {
			e.FieldStart("MechanicalProperties")
			s.MechanicalProperties.Encode(e)
		}
	}
	{
		if s.ThermalProperties.Set {
			e.FieldStart("ThermalProperties")
			s.ThermalProperties.Encode(e)
		}
	}
	{
		if s.ElectricalProperties.Set {
			e.FieldStart("ElectricalProperties")
			s.ElectricalProperties.Encode(e)
		}
	}
}

var jsonFieldsNameOfMaterialPropertiesType = [5]string{
	0: "PhysicalProperties",
	1: "ChemicalProperties",
	2: "MechanicalProperties",
	3: "ThermalProperties",
	4: "ElectricalProperties",
}

// Decode decodes MaterialPropertiesType from json.
func (s *MaterialPropertiesType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MaterialPropertiesType to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "PhysicalProperties":
			if err := func() error {
				s.PhysicalProperties.Reset()
				if err := s.PhysicalProperties.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"PhysicalProperties\"")
			}
		case "ChemicalProperties":
			if err := func() error {
				s.ChemicalProperties.Reset()
				if err := s.ChemicalProperties.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ChemicalProperties\"")
			}
		case "MechanicalProperties":
			if err := func() error {
				s.MechanicalProperties.Reset()
				if err := s.MechanicalProperties.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"MechanicalProperties\"")
			}
		case "ThermalProperties":
			if err := func() error {
				s.ThermalProperties.Reset()
				if err := s.ThermalProperties.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ThermalProperties\"")
			}
		case "ElectricalProperties":
			if err := func() error {
				s.ElectricalProperties.Reset()
				if err := s.ElectricalProperties.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ElectricalProperties\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MaterialPropertiesType")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MaterialPropertiesType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MaterialPropertiesType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MaterialSourceType) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MaterialSourceType) encodeFields(e *jx.Encoder) {
	{
		if s.SourceID.Set {
			e.FieldStart("SourceID")
			s.SourceID.Encode(e)
		}
	}
	{
		if s.SourceName.Set {
			e.FieldStart("SourceName")
			s.SourceName.Encode(e)
		}
	}
	{
		if s.SourceLocation.Set {
			e.FieldStart("SourceLocation")
			s.SourceLocation.Encode(e)
		}
	}
	{
		if s.SupplyChainStep.Set {
			e.FieldStart("SupplyChainStep")
			s.SupplyChainStep.Encode(e)
		}
	}
}

var jsonFieldsNameOfMaterialSourceType = [4]string{
	0: "SourceID",
	1: "SourceName",
	2: "SourceLocation",
	3: "SupplyChainStep",
}

// Decode decodes MaterialSourceType from json.
func (s *MaterialSourceType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MaterialSourceType to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "SourceID":
			if err := func() error {
				s.SourceID.Reset()
				if err := s.SourceID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"SourceID\"")
			}
		case "SourceName":
			if err := func() error {
				s.SourceName.Reset()
				if err := s.SourceName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"SourceName\"")
			}
		case "SourceLocation":
			if err := func() error {
				s.SourceLocation.Reset()
				if err := s.SourceLocation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"SourceLocation\"")
			}
		case "SupplyChainStep":
			if err := func() error {
				s.SupplyChainStep.Reset()
				if err := s.SupplyChainStep.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"SupplyChainStep\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MaterialSourceType")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MaterialSourceType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MaterialSourceType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MaterialType) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MaterialType) encodeFields(e *jx.Encoder) {
	{
		if s.MaterialID.Set {
			e.FieldStart("MaterialID")
			s.MaterialID.Encode(e)
		}
	}
	{
		if s.MaterialDescription.Set {
			e.FieldStart("MaterialDescription")
			s.MaterialDescription.Encode(e)
		}
	}
	{
		if s.MaterialTypeCode.Set {
			e.FieldStart("MaterialTypeCode")
			s.MaterialTypeCode.Encode(e)
		}
	}
	{
		if s.MaterialCategory.Set {
			e.FieldStart("MaterialCategory")
			s.MaterialCategory.Encode(e)
		}
	}
	{
		if s.MaterialProperties.Set {
			e.FieldStart("MaterialProperties")
			s.MaterialProperties.Encode(e)
		}
	}
	{
		if s.MaterialComposition.Set {
			e.FieldStart("MaterialComposition")
			s.MaterialComposition.Encode(e)
		}
	}
	{
		if s.MaterialSource.Set {
			e.FieldStart("MaterialSource")
			s.MaterialSource.Encode(e)
		}
	}
	{
		if s.MaterialUsage.Set {
			e.FieldStart("MaterialUsage")
			s.MaterialUsage.Encode(e)
		}
	}
	{
		if s.MaterialHandlingInstructions.Set {
			e.FieldStart("MaterialHandlingInstructions")
			s.MaterialHandlingInstructions.Encode(e)
		}
	}
	{
		if s.RegulatoryInformation.Set {
			e.FieldStart("RegulatoryInformation")
			s.RegulatoryInformation.Encode(e)
		}
	}
	{
		if s.TraceabilityInformation.Set {
			e.FieldStart("TraceabilityInformation")
			s.TraceabilityInformation.Encode(e)
		}
	}
}

var jsonFieldsNameOfMaterialType = [11]string{
	0:  "MaterialID",
	1:  "MaterialDescription",
	2:  "MaterialTypeCode",
	3:  "MaterialCategory",
	4:  "MaterialProperties",
	5:  "MaterialComposition",
	6:  "MaterialSource",
	7:  "MaterialUsage",
	8:  "MaterialHandlingInstructions",
	9:  "RegulatoryInformation",
	10: "TraceabilityInformation",
}

// Decode decodes MaterialType from json.
func (s *MaterialType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MaterialType to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "MaterialID":
			if err := func() error {
				s.MaterialID.Reset()
				if err := s.MaterialID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"MaterialID\"")
			}
		case "MaterialDescription":
			if err := func() error {
				s.MaterialDescription.Reset()
				if err := s.MaterialDescription.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"MaterialDescription\"")
			}
		case "MaterialTypeCode":
			if err := func() error {
				s.MaterialTypeCode.Reset()
				if err := s.MaterialTypeCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"MaterialTypeCode\"")
			}
		case "MaterialCategory":
			if err := func() error {
				s.MaterialCategory.Reset()
				if err := s.MaterialCategory.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"MaterialCategory\"")
			}
		case "MaterialProperties":
			if err := func() error {
				s.MaterialProperties.Reset()
				if err := s.MaterialProperties.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"MaterialProperties\"")
			}
		case "MaterialComposition":
			if err := func() error {
				s.MaterialComposition.Reset()
				if err := s.MaterialComposition.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"MaterialComposition\"")
			}
		case "MaterialSource":
			if err := func() error {
				s.MaterialSource.Reset()
				if err := s.MaterialSource.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"MaterialSource\"")
			}
		case "MaterialUsage":
			if err := func() error {
				s.MaterialUsage.Reset()
				if err := s.MaterialUsage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"MaterialUsage\"")
			}
		case "MaterialHandlingInstructions":
			if err := func() error {
				s.MaterialHandlingInstructions.Reset()
				if err := s.MaterialHandlingInstructions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"MaterialHandlingInstructions\"")
			}
		case "RegulatoryInformation":
			if err := func() error {
				s.RegulatoryInformation.Reset()
				if err := s.RegulatoryInformation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"RegulatoryInformation\"")
			}
		case "TraceabilityInformation":
			if err := func() error {
				s.TraceabilityInformation.Reset()
				if err := s.TraceabilityInformation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"TraceabilityInformation\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MaterialType")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MaterialType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MaterialType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MaterialUsageType) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MaterialUsageType) encodeFields(e *jx.Encoder) {
	{
		if s.IntendedUse.Set {
			e.FieldStart("IntendedUse")
			s.IntendedUse.Encode(e)
		}
	}
	{
		if s.ApplicationMethod.Set {
			e.FieldStart("ApplicationMethod")
			s.ApplicationMethod.Encode(e)
		}
	}
	{
		if s.QuantityRequired.Set {
			e.FieldStart("QuantityRequired")
			s.QuantityRequired.Encode(e)
		}
	}
	{
		if s.UnitOfMeasure.Set {
			e.FieldStart("UnitOfMeasure")
			s.UnitOfMeasure.Encode(e)
		}
	}
}

var jsonFieldsNameOfMaterialUsageType = [4]string{
	0: "IntendedUse",
	1: "ApplicationMethod",
	2: "QuantityRequired",
	3: "UnitOfMeasure",
}

// Decode decodes MaterialUsageType from json.
func (s *MaterialUsageType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MaterialUsageType to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "IntendedUse":
			if err := func() error {
				s.IntendedUse.Reset()
				if err := s.IntendedUse.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"IntendedUse\"")
			}
		case "ApplicationMethod":
			if err := func() error {
				s.ApplicationMethod.Reset()
				if err := s.ApplicationMethod.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ApplicationMethod\"")
			}
		case "QuantityRequired":
			if err := func() error {
				s.QuantityRequired.Reset()
				if err := s.QuantityRequired.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"QuantityRequired\"")
			}
		case "UnitOfMeasure":
			if err := func() error {
				s.UnitOfMeasure.Reset()
				if err := s.UnitOfMeasure.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"UnitOfMeasure\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MaterialUsageType")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MaterialUsageType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MaterialUsageType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MechanicalPropertiesType) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MechanicalPropertiesType) encodeFields(e *jx.Encoder) {
	{
		if s.TensileStrength.Set {
			e.FieldStart("TensileStrength")
			s.TensileStrength.Encode(e)
		}
	}
	{
		if s.YieldStrength.Set {
			e.FieldStart("YieldStrength")
			s.YieldStrength.Encode(e)
		}
	}
	{
		if s.Elongation.Set {
			e.FieldStart("Elongation")
			s.Elongation.Encode(e)
		}
	}
	{
		if s.Hardness.Set {
			e.FieldStart("Hardness")
			s.Hardness.Encode(e)
		}
	}
}

var jsonFieldsNameOfMechanicalPropertiesType = [4]string{
	0: "TensileStrength",
	1: "YieldStrength",
	2: "Elongation",
	3: "Hardness",
}

// Decode decodes MechanicalPropertiesType from json.
func (s *MechanicalPropertiesType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MechanicalPropertiesType to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "TensileStrength":
			if err := func() error {
				s.TensileStrength.Reset()
				if err := s.TensileStrength.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"TensileStrength\"")
			}
		case "YieldStrength":
			if err := func() error {
				s.YieldStrength.Reset()
				if err := s.YieldStrength.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"YieldStrength\"")
			}
		case "Elongation":
			if err := func() error {
				s.Elongation.Reset()
				if err := s.Elongation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Elongation\"")
			}
		case "Hardness":
			if err := func() error {
				s.Hardness.Reset()
				if err := s.Hardness.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Hardness\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MechanicalPropertiesType")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MechanicalPropertiesType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MechanicalPropertiesType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MetricType) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MetricType) encodeFields(e *jx.Encoder) {
	{
		if s.MetricName.Set {
			e.FieldStart("MetricName")
			s.MetricName.Encode(e)
		}
	}
	{
		if s.Value.Set {
			e.FieldStart("Value")
			s.Value.Encode(e)
		}
	}
	{
		if s.UnitOfMeasure.Set {
			e.FieldStart("UnitOfMeasure")
			s.UnitOfMeasure.Encode(e)
		}
	}
	{
		if s.Timestamp.Set {
			e.FieldStart("Timestamp")
			s.Timestamp.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfMetricType = [4]string{
	0: "MetricName",
	1: "Value",
	2: "UnitOfMeasure",
	3: "Timestamp",
}

// Decode decodes MetricType from json.
func (s *MetricType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MetricType to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "MetricName":
			if err := func() error {
				s.MetricName.Reset()
				if err := s.MetricName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"MetricName\"")
			}
		case "Value":
			if err := func() error {
				s.Value.Reset()
				if err := s.Value.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Value\"")
			}
		case "UnitOfMeasure":
			if err := func() error {
				s.UnitOfMeasure.Reset()
				if err := s.UnitOfMeasure.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"UnitOfMeasure\"")
			}
		case "Timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Timestamp\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MetricType")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MetricType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MetricType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AdditivesType as json.
func (o OptAdditivesType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes AdditivesType from json.
func (o *OptAdditivesType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAdditivesType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAdditivesType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAdditivesType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BatchRecordsType as json.
func (o OptBatchRecordsType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes BatchRecordsType from json.
func (o *OptBatchRecordsType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBatchRecordsType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBatchRecordsType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBatchRecordsType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BatchTypeBatchStatus as json.
func (o OptBatchTypeBatchStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes BatchTypeBatchStatus from json.
func (o *OptBatchTypeBatchStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBatchTypeBatchStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBatchTypeBatchStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBatchTypeBatchStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CertificationDetailsType as json.
func (o OptCertificationDetailsType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CertificationDetailsType from json.
func (o *OptCertificationDetailsType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCertificationDetailsType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCertificationDetailsType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCertificationDetailsType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ChemicalPropertiesType as json.
func (o OptChemicalPropertiesType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ChemicalPropertiesType from json.
func (o *OptChemicalPropertiesType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptChemicalPropertiesType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptChemicalPropertiesType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptChemicalPropertiesType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ContaminantsType as json.
func (o OptContaminantsType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ContaminantsType from json.
func (o *OptContaminantsType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptContaminantsType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptContaminantsType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptContaminantsType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CoordinatesType as json.
func (o OptCoordinatesType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CoordinatesType from json.
func (o *OptCoordinatesType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCoordinatesType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCoordinatesType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCoordinatesType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes time.Time as json.
func (o OptDate) Encode(e *jx.Encoder, format func(*jx.Encoder, time.Time)) {
	if !o.Set {
		return
	}
	format(e, o.Value)
}

// Decode decodes time.Time from json.
func (o *OptDate) Decode(d *jx.Decoder, format func(*jx.Decoder) (time.Time, error)) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDate to nil")
	}
	o.Set = true
	v, err := format(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e, json.EncodeDate)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d, json.DecodeDate)
}

// Encode encodes time.Time as json.
func (o OptDateTime) Encode(e *jx.Encoder, format func(*jx.Encoder, time.Time)) {
	if !o.Set {
		return
	}
	format(e, o.Value)
}

// Decode decodes time.Time from json.
func (o *OptDateTime) Decode(d *jx.Decoder, format func(*jx.Decoder) (time.Time, error)) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDateTime to nil")
	}
	o.Set = true
	v, err := format(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDateTime) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e, json.EncodeDateTime)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDateTime) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d, json.DecodeDateTime)
}

// Encode encodes ElectricalPropertiesType as json.
func (o OptElectricalPropertiesType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ElectricalPropertiesType from json.
func (o *OptElectricalPropertiesType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptElectricalPropertiesType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptElectricalPropertiesType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptElectricalPropertiesType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes float64 as json.
func (o OptFloat64) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Float64(float64(o.Value))
}

// Decode decodes float64 from json.
func (o *OptFloat64) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFloat64 to nil")
	}
	o.Set = true
	v, err := d.Float64()
	if err != nil {
		return err
	}
	o.Value = float64(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptFloat64) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptFloat64) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HierarchyScopeType as json.
func (o OptHierarchyScopeType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes HierarchyScopeType from json.
func (o *OptHierarchyScopeType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptHierarchyScopeType to nil")
	}
	o.Set = true
	o.Value = make(HierarchyScopeType)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptHierarchyScopeType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptHierarchyScopeType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes LocationType as json.
func (o OptLocationType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes LocationType from json.
func (o *OptLocationType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptLocationType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptLocationType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptLocationType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes MaintenanceHistoryType as json.
func (o OptMaintenanceHistoryType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes MaintenanceHistoryType from json.
func (o *OptMaintenanceHistoryType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptMaintenanceHistoryType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptMaintenanceHistoryType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptMaintenanceHistoryType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes MaterialCategoryType as json.
func (o OptMaterialCategoryType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes MaterialCategoryType from json.
func (o *OptMaterialCategoryType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptMaterialCategoryType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptMaterialCategoryType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptMaterialCategoryType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes MaterialCompositionType as json.
func (o OptMaterialCompositionType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes MaterialCompositionType from json.
func (o *OptMaterialCompositionType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptMaterialCompositionType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptMaterialCompositionType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptMaterialCompositionType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes MaterialPropertiesType as json.
func (o OptMaterialPropertiesType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes MaterialPropertiesType from json.
func (o *OptMaterialPropertiesType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptMaterialPropertiesType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptMaterialPropertiesType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptMaterialPropertiesType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes MaterialSourceType as json.
func (o OptMaterialSourceType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes MaterialSourceType from json.
func (o *OptMaterialSourceType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptMaterialSourceType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptMaterialSourceType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptMaterialSourceType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes MaterialUsageType as json.
func (o OptMaterialUsageType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes MaterialUsageType from json.
func (o *OptMaterialUsageType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptMaterialUsageType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptMaterialUsageType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptMaterialUsageType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes MechanicalPropertiesType as json.
func (o OptMechanicalPropertiesType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes MechanicalPropertiesType from json.
func (o *OptMechanicalPropertiesType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptMechanicalPropertiesType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptMechanicalPropertiesType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptMechanicalPropertiesType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PerformanceDataType as json.
func (o OptPerformanceDataType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PerformanceDataType from json.
func (o *OptPerformanceDataType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPerformanceDataType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPerformanceDataType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPerformanceDataType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PhysicalPropertiesType as json.
func (o OptPhysicalPropertiesType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PhysicalPropertiesType from json.
func (o *OptPhysicalPropertiesType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPhysicalPropertiesType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPhysicalPropertiesType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPhysicalPropertiesType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RecordTypeRecordData as json.
func (o OptRecordTypeRecordData) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes RecordTypeRecordData from json.
func (o *OptRecordTypeRecordData) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRecordTypeRecordData to nil")
	}
	o.Set = true
	o.Value = make(RecordTypeRecordData)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptRecordTypeRecordData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptRecordTypeRecordData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RegulatoryInformationType as json.
func (o OptRegulatoryInformationType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes RegulatoryInformationType from json.
func (o *OptRegulatoryInformationType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRegulatoryInformationType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptRegulatoryInformationType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptRegulatoryInformationType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ResourceLocationType as json.
func (o OptResourceLocationType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ResourceLocationType from json.
func (o *OptResourceLocationType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptResourceLocationType to nil")
	}
	o.Set = true
	o.Value = make(ResourceLocationType)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptResourceLocationType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptResourceLocationType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SpatialDefinitionType as json.
func (o OptSpatialDefinitionType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SpatialDefinitionType from json.
func (o *OptSpatialDefinitionType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSpatialDefinitionType to nil")
	}
	o.Set = true
	o.Value = make(SpatialDefinitionType)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSpatialDefinitionType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSpatialDefinitionType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o OptString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptString to nil")
	}
	o.Set = true
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ThermalPropertiesType as json.
func (o OptThermalPropertiesType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ThermalPropertiesType from json.
func (o *OptThermalPropertiesType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptThermalPropertiesType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptThermalPropertiesType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptThermalPropertiesType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TraceabilityInformationType as json.
func (o OptTraceabilityInformationType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes TraceabilityInformationType from json.
func (o *OptTraceabilityInformationType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTraceabilityInformationType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTraceabilityInformationType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTraceabilityInformationType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PerformanceDataType) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PerformanceDataType) encodeFields(e *jx.Encoder) {
	{
		if s.Metric != nil {
			e.FieldStart("Metric")
			e.ArrStart()
			for _, elem := range s.Metric {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfPerformanceDataType = [1]string{
	0: "Metric",
}

// Decode decodes PerformanceDataType from json.
func (s *PerformanceDataType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PerformanceDataType to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "Metric":
			if err := func() error {
				s.Metric = make([]MetricType, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem MetricType
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Metric = append(s.Metric, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Metric\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PerformanceDataType")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PerformanceDataType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PerformanceDataType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PersonPropertyType) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PersonPropertyType) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("ID")
		e.Str(s.ID)
	}
	{
		if s.Description != nil {
			e.FieldStart("Description")
			e.ArrStart()
			for _, elem := range s.Description {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Value != nil {
			e.FieldStart("Value")
			e.ArrStart()
			for _, elem := range s.Value {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.PersonPropertyChild != nil {
			e.FieldStart("PersonPropertyChild")
			e.ArrStart()
			for _, elem := range s.PersonPropertyChild {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.PersonnelClassPropertyID.Set {
			e.FieldStart("PersonnelClassPropertyID")
			s.PersonnelClassPropertyID.Encode(e)
		}
	}
}

var jsonFieldsNameOfPersonPropertyType = [5]string{
	0: "ID",
	1: "Description",
	2: "Value",
	3: "PersonPropertyChild",
	4: "PersonnelClassPropertyID",
}

// Decode decodes PersonPropertyType from json.
func (s *PersonPropertyType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PersonPropertyType to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ID":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ID\"")
			}
		case "Description":
			if err := func() error {
				s.Description = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Description = append(s.Description, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Description\"")
			}
		case "Value":
			if err := func() error {
				s.Value = make([]ValueType, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ValueType
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Value = append(s.Value, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Value\"")
			}
		case "PersonPropertyChild":
			if err := func() error {
				s.PersonPropertyChild = make([]PersonPropertyType, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem PersonPropertyType
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.PersonPropertyChild = append(s.PersonPropertyChild, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"PersonPropertyChild\"")
			}
		case "PersonnelClassPropertyID":
			if err := func() error {
				s.PersonnelClassPropertyID.Reset()
				if err := s.PersonnelClassPropertyID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"PersonnelClassPropertyID\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PersonPropertyType")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPersonPropertyType) {
					name = jsonFieldsNameOfPersonPropertyType[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PersonPropertyType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PersonPropertyType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PersonType) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PersonType) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("ID")
		e.Str(s.ID)
	}
	{
		if s.Version.Set {
			e.FieldStart("Version")
			s.Version.Encode(e)
		}
	}
	{
		if s.Description != nil {
			e.FieldStart("Description")
			e.ArrStart()
			for _, elem := range s.Description {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.PublishedDate.Set {
			e.FieldStart("PublishedDate")
			s.PublishedDate.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.EffectiveStartDate.Set {
			e.FieldStart("EffectiveStartDate")
			s.EffectiveStartDate.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.EffectiveEndDate.Set {
			e.FieldStart("EffectiveEndDate")
			s.EffectiveEndDate.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.HierarchyScope.Set {
			e.FieldStart("HierarchyScope")
			s.HierarchyScope.Encode(e)
		}
	}
	{
		if s.PersonName.Set {
			e.FieldStart("PersonName")
			s.PersonName.Encode(e)
		}
	}
	{
		if s.SpatialDefinition.Set {
			e.FieldStart("SpatialDefinition")
			s.SpatialDefinition.Encode(e)
		}
	}
	{
		if s.OperationalLocation.Set {
			e.FieldStart("OperationalLocation")
			s.OperationalLocation.Encode(e)
		}
	}
	{
		if s.PersonProperty != nil {
			e.FieldStart("PersonProperty")
			e.ArrStart()
			for _, elem := range s.PersonProperty {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.PersonnelClassID != nil {
			e.FieldStart("PersonnelClassID")
			e.ArrStart()
			for _, elem := range s.PersonnelClassID {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.TestSpecificationID != nil {
			e.FieldStart("TestSpecificationID")
			e.ArrStart()
			for _, elem := range s.TestSpecificationID {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfPersonType = [13]string{
	0:  "ID",
	1:  "Version",
	2:  "Description",
	3:  "PublishedDate",
	4:  "EffectiveStartDate",
	5:  "EffectiveEndDate",
	6:  "HierarchyScope",
	7:  "PersonName",
	8:  "SpatialDefinition",
	9:  "OperationalLocation",
	10: "PersonProperty",
	11: "PersonnelClassID",
	12: "TestSpecificationID",
}

// Decode decodes PersonType from json.
func (s *PersonType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PersonType to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ID":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ID\"")
			}
		case "Version":
			if err := func() error {
				s.Version.Reset()
				if err := s.Version.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Version\"")
			}
		case "Description":
			if err := func() error {
				s.Description = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Description = append(s.Description, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Description\"")
			}
		case "PublishedDate":
			if err := func() error {
				s.PublishedDate.Reset()
				if err := s.PublishedDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"PublishedDate\"")
			}
		case "EffectiveStartDate":
			if err := func() error {
				s.EffectiveStartDate.Reset()
				if err := s.EffectiveStartDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"EffectiveStartDate\"")
			}
		case "EffectiveEndDate":
			if err := func() error {
				s.EffectiveEndDate.Reset()
				if err := s.EffectiveEndDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"EffectiveEndDate\"")
			}
		case "HierarchyScope":
			if err := func() error {
				s.HierarchyScope.Reset()
				if err := s.HierarchyScope.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"HierarchyScope\"")
			}
		case "PersonName":
			if err := func() error {
				s.PersonName.Reset()
				if err := s.PersonName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"PersonName\"")
			}
		case "SpatialDefinition":
			if err := func() error {
				s.SpatialDefinition.Reset()
				if err := s.SpatialDefinition.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"SpatialDefinition\"")
			}
		case "OperationalLocation":
			if err := func() error {
				s.OperationalLocation.Reset()
				if err := s.OperationalLocation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"OperationalLocation\"")
			}
		case "PersonProperty":
			if err := func() error {
				s.PersonProperty = make([]PersonPropertyType, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem PersonPropertyType
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.PersonProperty = append(s.PersonProperty, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"PersonProperty\"")
			}
		case "PersonnelClassID":
			if err := func() error {
				s.PersonnelClassID = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.PersonnelClassID = append(s.PersonnelClassID, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"PersonnelClassID\"")
			}
		case "TestSpecificationID":
			if err := func() error {
				s.TestSpecificationID = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.TestSpecificationID = append(s.TestSpecificationID, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"TestSpecificationID\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PersonType")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000001,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPersonType) {
					name = jsonFieldsNameOfPersonType[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PersonType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PersonType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PersonnelClassPropertyType) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PersonnelClassPropertyType) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("ID")
		e.Str(s.ID)
	}
	{
		if s.Description != nil {
			e.FieldStart("Description")
			e.ArrStart()
			for _, elem := range s.Description {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.PropertyType.Set {
			e.FieldStart("PropertyType")
			s.PropertyType.Encode(e)
		}
	}
	{
		if s.Value != nil {
			e.FieldStart("Value")
			e.ArrStart()
			for _, elem := range s.Value {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.PersonnelClassPropertyChild != nil {
			e.FieldStart("PersonnelClassPropertyChild")
			e.ArrStart()
			for _, elem := range s.PersonnelClassPropertyChild {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfPersonnelClassPropertyType = [5]string{
	0: "ID",
	1: "Description",
	2: "PropertyType",
	3: "Value",
	4: "PersonnelClassPropertyChild",
}

// Decode decodes PersonnelClassPropertyType from json.
func (s *PersonnelClassPropertyType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PersonnelClassPropertyType to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ID":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ID\"")
			}
		case "Description":
			if err := func() error {
				s.Description = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Description = append(s.Description, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Description\"")
			}
		case "PropertyType":
			if err := func() error {
				s.PropertyType.Reset()
				if err := s.PropertyType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"PropertyType\"")
			}
		case "Value":
			if err := func() error {
				s.Value = make([]ValueType, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ValueType
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Value = append(s.Value, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Value\"")
			}
		case "PersonnelClassPropertyChild":
			if err := func() error {
				s.PersonnelClassPropertyChild = make([]PersonnelClassPropertyType, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem PersonnelClassPropertyType
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.PersonnelClassPropertyChild = append(s.PersonnelClassPropertyChild, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"PersonnelClassPropertyChild\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PersonnelClassPropertyType")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPersonnelClassPropertyType) {
					name = jsonFieldsNameOfPersonnelClassPropertyType[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PersonnelClassPropertyType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PersonnelClassPropertyType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PersonnelClassType) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PersonnelClassType) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("ID")
		e.Str(s.ID)
	}
	{
		if s.Version.Set {
			e.FieldStart("Version")
			s.Version.Encode(e)
		}
	}
	{
		if s.Description != nil {
			e.FieldStart("Description")
			e.ArrStart()
			for _, elem := range s.Description {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.PublishedDate.Set {
			e.FieldStart("PublishedDate")
			s.PublishedDate.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.EffectiveStartDate.Set {
			e.FieldStart("EffectiveStartDate")
			s.EffectiveStartDate.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.EffectiveEndDate.Set {
			e.FieldStart("EffectiveEndDate")
			s.EffectiveEndDate.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.HierarchyScope.Set {
			e.FieldStart("HierarchyScope")
			s.HierarchyScope.Encode(e)
		}
	}
	{
		if s.PersonnelClassBaseID != nil {
			e.FieldStart("PersonnelClassBaseID")
			e.ArrStart()
			for _, elem := range s.PersonnelClassBaseID {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.PersonnelClassProperty != nil {
			e.FieldStart("PersonnelClassProperty")
			e.ArrStart()
			for _, elem := range s.PersonnelClassProperty {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.PersonSourceID != nil {
			e.FieldStart("PersonSourceID")
			e.ArrStart()
			for _, elem := range s.PersonSourceID {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.TestSpecificationID != nil {
			e.FieldStart("TestSpecificationID")
			e.ArrStart()
			for _, elem := range s.TestSpecificationID {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfPersonnelClassType = [11]string{
	0:  "ID",
	1:  "Version",
	2:  "Description",
	3:  "PublishedDate",
	4:  "EffectiveStartDate",
	5:  "EffectiveEndDate",
	6:  "HierarchyScope",
	7:  "PersonnelClassBaseID",
	8:  "PersonnelClassProperty",
	9:  "PersonSourceID",
	10: "TestSpecificationID",
}

// Decode decodes PersonnelClassType from json.
func (s *PersonnelClassType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PersonnelClassType to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ID":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ID\"")
			}
		case "Version":
			if err := func() error {
				s.Version.Reset()
				if err := s.Version.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Version\"")
			}
		case "Description":
			if err := func() error {
				s.Description = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Description = append(s.Description, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Description\"")
			}
		case "PublishedDate":
			if err := func() error {
				s.PublishedDate.Reset()
				if err := s.PublishedDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"PublishedDate\"")
			}
		case "EffectiveStartDate":
			if err := func() error {
				s.EffectiveStartDate.Reset()
				if err := s.EffectiveStartDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"EffectiveStartDate\"")
			}
		case "EffectiveEndDate":
			if err := func() error {
				s.EffectiveEndDate.Reset()
				if err := s.EffectiveEndDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"EffectiveEndDate\"")
			}
		case "HierarchyScope":
			if err := func() error {
				s.HierarchyScope.Reset()
				if err := s.HierarchyScope.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"HierarchyScope\"")
			}
		case "PersonnelClassBaseID":
			if err := func() error {
				s.PersonnelClassBaseID = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.PersonnelClassBaseID = append(s.PersonnelClassBaseID, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"PersonnelClassBaseID\"")
			}
		case "PersonnelClassProperty":
			if err := func() error {
				s.PersonnelClassProperty = make([]PersonnelClassPropertyType, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem PersonnelClassPropertyType
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.PersonnelClassProperty = append(s.PersonnelClassProperty, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"PersonnelClassProperty\"")
			}
		case "PersonSourceID":
			if err := func() error {
				s.PersonSourceID = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.PersonSourceID = append(s.PersonSourceID, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"PersonSourceID\"")
			}
		case "TestSpecificationID":
			if err := func() error {
				s.TestSpecificationID = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.TestSpecificationID = append(s.TestSpecificationID, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"TestSpecificationID\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PersonnelClassType")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000001,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPersonnelClassType) {
					name = jsonFieldsNameOfPersonnelClassType[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PersonnelClassType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PersonnelClassType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PersonnelInformationType) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PersonnelInformationType) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("ID")
			s.ID.Encode(e)
		}
	}
	{
		if s.Description != nil {
			e.FieldStart("Description")
			e.ArrStart()
			for _, elem := range s.Description {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.HierarchyScope.Set {
			e.FieldStart("HierarchyScope")
			s.HierarchyScope.Encode(e)
		}
	}
	{
		if s.PublishedDate.Set {
			e.FieldStart("PublishedDate")
			s.PublishedDate.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Person != nil {
			e.FieldStart("Person")
			e.ArrStart()
			for _, elem := range s.Person {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.PersonnelClass != nil {
			e.FieldStart("PersonnelClass")
			e.ArrStart()
			for _, elem := range s.PersonnelClass {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.TestSpecification != nil {
			e.FieldStart("TestSpecification")
			e.ArrStart()
			for _, elem := range s.TestSpecification {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfPersonnelInformationType = [7]string{
	0: "ID",
	1: "Description",
	2: "HierarchyScope",
	3: "PublishedDate",
	4: "Person",
	5: "PersonnelClass",
	6: "TestSpecification",
}

// Decode decodes PersonnelInformationType from json.
func (s *PersonnelInformationType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PersonnelInformationType to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ID":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ID\"")
			}
		case "Description":
			if err := func() error {
				s.Description = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Description = append(s.Description, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Description\"")
			}
		case "HierarchyScope":
			if err := func() error {
				s.HierarchyScope.Reset()
				if err := s.HierarchyScope.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"HierarchyScope\"")
			}
		case "PublishedDate":
			if err := func() error {
				s.PublishedDate.Reset()
				if err := s.PublishedDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"PublishedDate\"")
			}
		case "Person":
			if err := func() error {
				s.Person = make([]PersonType, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem PersonType
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Person = append(s.Person, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Person\"")
			}
		case "PersonnelClass":
			if err := func() error {
				s.PersonnelClass = make([]PersonnelClassType, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem PersonnelClassType
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.PersonnelClass = append(s.PersonnelClass, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"PersonnelClass\"")
			}
		case "TestSpecification":
			if err := func() error {
				s.TestSpecification = make([]TestSpecificationType, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem TestSpecificationType
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.TestSpecification = append(s.TestSpecification, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"TestSpecification\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PersonnelInformationType")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PersonnelInformationType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PersonnelInformationType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PhysicalPropertiesType) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PhysicalPropertiesType) encodeFields(e *jx.Encoder) {
	{
		if s.Density.Set {
			e.FieldStart("Density")
			s.Density.Encode(e)
		}
	}
	{
		if s.Viscosity.Set {
			e.FieldStart("Viscosity")
			s.Viscosity.Encode(e)
		}
	}
	{
		if s.ParticleSize.Set {
			e.FieldStart("ParticleSize")
			s.ParticleSize.Encode(e)
		}
	}
	{
		if s.SurfaceArea.Set {
			e.FieldStart("SurfaceArea")
			s.SurfaceArea.Encode(e)
		}
	}
}

var jsonFieldsNameOfPhysicalPropertiesType = [4]string{
	0: "Density",
	1: "Viscosity",
	2: "ParticleSize",
	3: "SurfaceArea",
}

// Decode decodes PhysicalPropertiesType from json.
func (s *PhysicalPropertiesType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PhysicalPropertiesType to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "Density":
			if err := func() error {
				s.Density.Reset()
				if err := s.Density.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Density\"")
			}
		case "Viscosity":
			if err := func() error {
				s.Viscosity.Reset()
				if err := s.Viscosity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Viscosity\"")
			}
		case "ParticleSize":
			if err := func() error {
				s.ParticleSize.Reset()
				if err := s.ParticleSize.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ParticleSize\"")
			}
		case "SurfaceArea":
			if err := func() error {
				s.SurfaceArea.Reset()
				if err := s.SurfaceArea.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"SurfaceArea\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PhysicalPropertiesType")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PhysicalPropertiesType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PhysicalPropertiesType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RecordType) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RecordType) encodeFields(e *jx.Encoder) {
	{
		if s.RecordID.Set {
			e.FieldStart("RecordID")
			s.RecordID.Encode(e)
		}
	}
	{
		if s.RecordType.Set {
			e.FieldStart("RecordType")
			s.RecordType.Encode(e)
		}
	}
	{
		if s.RecordData.Set {
			e.FieldStart("RecordData")
			s.RecordData.Encode(e)
		}
	}
}

var jsonFieldsNameOfRecordType = [3]string{
	0: "RecordID",
	1: "RecordType",
	2: "RecordData",
}

// Decode decodes RecordType from json.
func (s *RecordType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RecordType to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "RecordID":
			if err := func() error {
				s.RecordID.Reset()
				if err := s.RecordID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"RecordID\"")
			}
		case "RecordType":
			if err := func() error {
				s.RecordType.Reset()
				if err := s.RecordType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"RecordType\"")
			}
		case "RecordData":
			if err := func() error {
				s.RecordData.Reset()
				if err := s.RecordData.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"RecordData\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RecordType")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RecordType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RecordType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s RecordTypeRecordData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s RecordTypeRecordData) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes RecordTypeRecordData from json.
func (s *RecordTypeRecordData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RecordTypeRecordData to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RecordTypeRecordData")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RecordTypeRecordData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RecordTypeRecordData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RegulatoryInformationType) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RegulatoryInformationType) encodeFields(e *jx.Encoder) {
	{
		if s.RegulatoryStatus.Set {
			e.FieldStart("RegulatoryStatus")
			s.RegulatoryStatus.Encode(e)
		}
	}
	{
		if s.ComplianceStandards.Set {
			e.FieldStart("ComplianceStandards")
			s.ComplianceStandards.Encode(e)
		}
	}
	{
		if s.CertificationDetails.Set {
			e.FieldStart("CertificationDetails")
			s.CertificationDetails.Encode(e)
		}
	}
}

var jsonFieldsNameOfRegulatoryInformationType = [3]string{
	0: "RegulatoryStatus",
	1: "ComplianceStandards",
	2: "CertificationDetails",
}

// Decode decodes RegulatoryInformationType from json.
func (s *RegulatoryInformationType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RegulatoryInformationType to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "RegulatoryStatus":
			if err := func() error {
				s.RegulatoryStatus.Reset()
				if err := s.RegulatoryStatus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"RegulatoryStatus\"")
			}
		case "ComplianceStandards":
			if err := func() error {
				s.ComplianceStandards.Reset()
				if err := s.ComplianceStandards.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ComplianceStandards\"")
			}
		case "CertificationDetails":
			if err := func() error {
				s.CertificationDetails.Reset()
				if err := s.CertificationDetails.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"CertificationDetails\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RegulatoryInformationType")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RegulatoryInformationType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RegulatoryInformationType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s ResourceLocationType) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s ResourceLocationType) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes ResourceLocationType from json.
func (s *ResourceLocationType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ResourceLocationType to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ResourceLocationType")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ResourceLocationType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ResourceLocationType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s SpatialDefinitionType) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s SpatialDefinitionType) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes SpatialDefinitionType from json.
func (s *SpatialDefinitionType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SpatialDefinitionType to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SpatialDefinitionType")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SpatialDefinitionType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SpatialDefinitionType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TestSpecificationType) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TestSpecificationType) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("ID")
			s.ID.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("Description")
			s.Description.Encode(e)
		}
	}
	for k, elem := range s.AdditionalProps {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

var jsonFieldsNameOfTestSpecificationType = [2]string{
	0: "ID",
	1: "Description",
}

// Decode decodes TestSpecificationType from json.
func (s *TestSpecificationType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TestSpecificationType to nil")
	}
	s.AdditionalProps = map[string]jx.Raw{}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ID":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ID\"")
			}
		case "Description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Description\"")
			}
		default:
			var elem jx.Raw
			if err := func() error {
				v, err := d.RawAppend(nil)
				elem = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrapf(err, "decode field %q", k)
			}
			s.AdditionalProps[string(k)] = elem
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TestSpecificationType")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TestSpecificationType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TestSpecificationType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s TestSpecificationTypeAdditional) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s TestSpecificationTypeAdditional) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes TestSpecificationTypeAdditional from json.
func (s *TestSpecificationTypeAdditional) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TestSpecificationTypeAdditional to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TestSpecificationTypeAdditional")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TestSpecificationTypeAdditional) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TestSpecificationTypeAdditional) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ThermalPropertiesType) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ThermalPropertiesType) encodeFields(e *jx.Encoder) {
	{
		if s.MeltingPoint.Set {
			e.FieldStart("MeltingPoint")
			s.MeltingPoint.Encode(e)
		}
	}
	{
		if s.BoilingPoint.Set {
			e.FieldStart("BoilingPoint")
			s.BoilingPoint.Encode(e)
		}
	}
	{
		if s.ThermalConductivity.Set {
			e.FieldStart("ThermalConductivity")
			s.ThermalConductivity.Encode(e)
		}
	}
	{
		if s.SpecificHeat.Set {
			e.FieldStart("SpecificHeat")
			s.SpecificHeat.Encode(e)
		}
	}
}

var jsonFieldsNameOfThermalPropertiesType = [4]string{
	0: "MeltingPoint",
	1: "BoilingPoint",
	2: "ThermalConductivity",
	3: "SpecificHeat",
}

// Decode decodes ThermalPropertiesType from json.
func (s *ThermalPropertiesType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ThermalPropertiesType to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "MeltingPoint":
			if err := func() error {
				s.MeltingPoint.Reset()
				if err := s.MeltingPoint.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"MeltingPoint\"")
			}
		case "BoilingPoint":
			if err := func() error {
				s.BoilingPoint.Reset()
				if err := s.BoilingPoint.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"BoilingPoint\"")
			}
		case "ThermalConductivity":
			if err := func() error {
				s.ThermalConductivity.Reset()
				if err := s.ThermalConductivity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ThermalConductivity\"")
			}
		case "SpecificHeat":
			if err := func() error {
				s.SpecificHeat.Reset()
				if err := s.SpecificHeat.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"SpecificHeat\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ThermalPropertiesType")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ThermalPropertiesType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ThermalPropertiesType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TraceHistoryType) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TraceHistoryType) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("Timestamp")
			s.Timestamp.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Location.Set {
			e.FieldStart("Location")
			s.Location.Encode(e)
		}
	}
	{
		if s.Action.Set {
			e.FieldStart("Action")
			s.Action.Encode(e)
		}
	}
	{
		if s.ResponsibleParty.Set {
			e.FieldStart("ResponsibleParty")
			s.ResponsibleParty.Encode(e)
		}
	}
}

var jsonFieldsNameOfTraceHistoryType = [4]string{
	0: "Timestamp",
	1: "Location",
	2: "Action",
	3: "ResponsibleParty",
}

// Decode decodes TraceHistoryType from json.
func (s *TraceHistoryType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TraceHistoryType to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "Timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Timestamp\"")
			}
		case "Location":
			if err := func() error {
				s.Location.Reset()
				if err := s.Location.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Location\"")
			}
		case "Action":
			if err := func() error {
				s.Action.Reset()
				if err := s.Action.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Action\"")
			}
		case "ResponsibleParty":
			if err := func() error {
				s.ResponsibleParty.Reset()
				if err := s.ResponsibleParty.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ResponsibleParty\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TraceHistoryType")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TraceHistoryType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TraceHistoryType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TraceabilityInformationType) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TraceabilityInformationType) encodeFields(e *jx.Encoder) {
	{
		if s.BatchNumber.Set {
			e.FieldStart("BatchNumber")
			s.BatchNumber.Encode(e)
		}
	}
	{
		if s.LotNumber.Set {
			e.FieldStart("LotNumber")
			s.LotNumber.Encode(e)
		}
	}
	{
		if s.ProductionDate.Set {
			e.FieldStart("ProductionDate")
			s.ProductionDate.Encode(e, json.EncodeDate)
		}
	}
	{
		if s.ExpirationDate.Set {
			e.FieldStart("ExpirationDate")
			s.ExpirationDate.Encode(e, json.EncodeDate)
		}
	}
	{
		if s.TraceHistory != nil {
			e.FieldStart("TraceHistory")
			e.ArrStart()
			for _, elem := range s.TraceHistory {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfTraceabilityInformationType = [5]string{
	0: "BatchNumber",
	1: "LotNumber",
	2: "ProductionDate",
	3: "ExpirationDate",
	4: "TraceHistory",
}

// Decode decodes TraceabilityInformationType from json.
func (s *TraceabilityInformationType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TraceabilityInformationType to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "BatchNumber":
			if err := func() error {
				s.BatchNumber.Reset()
				if err := s.BatchNumber.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"BatchNumber\"")
			}
		case "LotNumber":
			if err := func() error {
				s.LotNumber.Reset()
				if err := s.LotNumber.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"LotNumber\"")
			}
		case "ProductionDate":
			if err := func() error {
				s.ProductionDate.Reset()
				if err := s.ProductionDate.Decode(d, json.DecodeDate); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ProductionDate\"")
			}
		case "ExpirationDate":
			if err := func() error {
				s.ExpirationDate.Reset()
				if err := s.ExpirationDate.Decode(d, json.DecodeDate); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ExpirationDate\"")
			}
		case "TraceHistory":
			if err := func() error {
				s.TraceHistory = make([]TraceHistoryType, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem TraceHistoryType
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.TraceHistory = append(s.TraceHistory, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"TraceHistory\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TraceabilityInformationType")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TraceabilityInformationType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TraceabilityInformationType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ValueType) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ValueType) encodeFields(e *jx.Encoder) {
	{
		if s.Value.Set {
			e.FieldStart("value")
			s.Value.Encode(e)
		}
	}
	{
		if s.UnitOfMeasure.Set {
			e.FieldStart("unitOfMeasure")
			s.UnitOfMeasure.Encode(e)
		}
	}
}

var jsonFieldsNameOfValueType = [2]string{
	0: "value",
	1: "unitOfMeasure",
}

// Decode decodes ValueType from json.
func (s *ValueType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValueType to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "value":
			if err := func() error {
				s.Value.Reset()
				if err := s.Value.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		case "unitOfMeasure":
			if err := func() error {
				s.UnitOfMeasure.Reset()
				if err := s.UnitOfMeasure.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"unitOfMeasure\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ValueType")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ValueType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValueType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}
